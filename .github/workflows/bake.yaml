name: Bake images

on:
  schedule:
    - cron: 0 8 * * 1
  workflow_dispatch:
    inputs:
      environment:
        type: choice
        options:
          - testing
          - production
        default: testing
        description: "Choose the environment to bake the images for"
      target:
        type: string
        default: ""
        description: "A comma separated list of targets to build. If empty, all targets will be built."

permissions: read-all

jobs:
  # Start by building images for testing. We want to run security checks before pushing those to production.
  testbuild:
    name: Build for testing
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
      security-events: write
      # Required by the cosign step
      id-token: write
    outputs:
      metadata: ${{ steps.build.outputs.metadata }}
      images: ${{ steps.images.outputs.images }}
    steps:
      - name: Checkout Code
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5

      - name: Log in to the GitHub Container registry
        uses: docker/login-action@184bdaa0721073962dff0199f1fb9940f07167d1 # v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # TODO: review this when GitHub has linux/arm64 runners available (Q1 2025?)
      #   https://github.com/github/roadmap/issues/970
      - name: Set up QEMU
        uses: docker/setup-qemu-action@29109295f81e9208d7d86ff1c6c12d2833863392 # v3
        with:
          platforms: 'arm64'

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@e468171a9de216ec08956ac3ada2f0791b6bd435 # v3

      - name: Build and push
        uses: docker/bake-action@3acf805d94d93a86cce4ca44798a76464a75b88c # v6
        id: build
        env:
          environment: testing
          registry: ghcr.io/${{ github.repository_owner }}
          revision: ${{ github.sha }}
        with:
          push: true
          targets: ${{ github.event.inputs.target }}

      # Get a list of the images that were built and pushed. We only care about a single tag for each image.
      - name: Generated images
        id: images
        run: |
          echo "images=$(echo '${{ steps.build.outputs.metadata }}' | jq -c '[ .[]."image.name" | sub(",.*";"") ]')" >>  "$GITHUB_OUTPUT"

      # Even if we're testing we sign the images, so we can push them to production later if that's required
      - name: Install cosign
        uses: sigstore/cosign-installer@398d4b0eeef1380460a10c8013a76f728fb906ac # v3
        # See https://github.blog/security/supply-chain-security/safeguard-container-signing-capability-actions/
        # and https://github.com/actions/starter-workflows/blob/main/ci/docker-publish.yml for more details on
        # how to use cosign.
      - name: Sign images
        run: |
          echo '${{ steps.build.outputs.metadata }}' | \
            jq '.[] | (."image.name" | sub(",.*";"" )) + "@" + ."containerimage.digest"' | \
            xargs cosign sign --yes

      - name: Create Image Catalogs
        run: |
          IMAGES=$(
          echo '${{ steps.build.outputs.metadata }}' |
              jq -r '.[] as $items |
                  $items."image.name" | split(",")[] + "@" + $items."containerimage.digest" |
                  select (. | test("-[0-9]{12}-[a-zA-Z]+")) |
                  sub("-testing"; "") |
                  capture("(?<image>[^:]+:(?<major>[^.]+).*-(?<variant>[^-]+)-(?<distro>[^@]+).*)") |
                  tojson'
          )

          for IMAGE in $IMAGES
          do
              export IMAGE_NAME=$(echo $IMAGE | jq -r '.image')
              export IMAGE_MAJOR=$(echo $IMAGE | jq -r '.major')
              export IMAGE_VARIANT=$(echo $IMAGE | jq -r '.variant')
              export IMAGE_DISTRO=$(echo $IMAGE | jq -r '.distro')

              yq --null-input '{
                    "apiVersion": "postgresql.cnpg.io/v1",
                    "kind": "ClusterImageCatalog",
                    "metadata": {"name":"postgresql-" + env(IMAGE_VARIANT) + "-" + env(IMAGE_DISTRO)},
                    "spec": {
                      "images": [
                        {
                          "major": env(IMAGE_MAJOR),
                          "image": env(IMAGE_NAME)
                        }
                      ]
                    }
                  }' > temp_ClusterImageCatalog-$IMAGE_MAJOR-$IMAGE_VARIANT-$IMAGE_DISTRO.yaml
          done

          IMAGES_ARRAY=$(echo $IMAGES | jq --slurp '.')

          DISTRIBUTIONS=$(echo $IMAGES_ARRAY | jq -r 'map(.distro) | unique | join(" ")')
          VARIANTS=$(echo $IMAGES_ARRAY | jq -r 'map(.variant) | unique | join(" ")')

          for VARIANT in $VARIANTS
          do
            for DISTRIBUTION in $DISTRIBUTIONS
            do
              yq eval-all '. as $item ireduce ({}; . *+ $item )' temp_ClusterImageCatalog-*-$VARIANT-$DISTRIBUTION.yaml > ClusterImageCatalog-$VARIANT-$DISTRIBUTION.yaml
              echo "Distribution: $DISTRIBUTION, variant: $VARIANT"
              cat ClusterImageCatalog-$VARIANT-$DISTRIBUTION.yaml
            done
          done

      - name: Upload Image Catalogs
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4
        with:
          name: ClusterImageCatalogs
          path: ClusterImageCatalog-*.yaml

  security:
    name: Security checks
    runs-on: ubuntu-latest
    needs:
      - testbuild
    strategy:
      matrix:
        image: ${{fromJson(needs.testbuild.outputs.images)}}
    steps:
      - name: Checkout Code
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5

      - name: Log in to the GitHub Container registry
        uses: docker/login-action@184bdaa0721073962dff0199f1fb9940f07167d1 # v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Dockle
        uses: erzz/dockle-action@69369bc745ee29813f730231a821bcd4f71cd290 # v1
        with:
          image: ${{ matrix.image }}
          exit-code: '1'

      - name: Snyk
        uses: snyk/actions/docker@master
        continue-on-error: true
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
        with:
          image: "${{ matrix.image }}"
          args: --severity-threshold=high --file=Dockerfile

      - name: Upload result to GitHub Code Scanning
        uses: github/codeql-action/upload-sarif@96f518a34f7a870018057716cc4d7a5c014bd61c # v3
        continue-on-error: true
        with:
          sarif_file: snyk.sarif

  # Use the metadata generated in the `testbuild` step to find all the images
  # that have been built. We copy them one by one to the production registry
  # using skopeo. Then we sign the production images too.
  copytoproduction:
    name: Copy images to production
    if: |
      github.ref == 'refs/heads/main' &&
      ( github.event.inputs.environment == 'production' || github.event_name == 'schedule' )
    runs-on: ubuntu-latest
    needs:
      - testbuild
      - security
    permissions:
      contents: read
      packages: write
      security-events: write
      # Required by the cosign step
      id-token: write
    steps:
      - name: Log in to the GitHub Container registry
        uses: docker/login-action@184bdaa0721073962dff0199f1fb9940f07167d1 # v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Copy images
        run: |
          images=$(echo '${{ needs.testbuild.outputs.metadata }}' |
            jq -r '
              .[] as $items |
              (
                $items."image.name" |
                split(",")[] +
                  "@" +
                  $items."containerimage.digest"
              )
            '
          )
          for image in $images
          do
            testimageshaonly="${image%:*@*}@${image#*@}"
            testimagenosha="${image%@*}"
            prodimage="${testimagenosha/-testing/}"
            echo "Copying ${testimageshaonly} to ${prodimage}"
            docker run --quiet quay.io/skopeo/stable:v1.17.0-immutable copy -q -a \
              --dest-creds ${{ github.actor }}:${{ secrets.GITHUB_TOKEN }} \
              docker://${testimageshaonly} docker://${prodimage}
          done

      - name: Install cosign
        uses: sigstore/cosign-installer@398d4b0eeef1380460a10c8013a76f728fb906ac # v3

      - name: Sign images
        run: |
          images=$(echo '${{ needs.testbuild.outputs.metadata }}' |
            jq -r '.[] |
              (
                ."image.name" |
                sub(",.*";"") |
                sub("-testing:[^@]+";"")
              ) + "@" + ."containerimage.digest"
            '
          )
          echo "Signing ${images}"
          cosign sign --yes ${images}
